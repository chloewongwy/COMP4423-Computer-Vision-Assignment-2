# -*- coding: utf-8 -*-
"""Raysampling.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nE0c_ert3_Ykp9daM5s0jMVWA8ZInDzb
"""

import numpy as np
import matplotlib.pyplot as plt

def generate_rays(H, W, focal, camera_pose):
    """
    Generate rays: returns ray origins and directions.
    """
    i, j = np.meshgrid(np.arange(W), np.arange(H), indexing='xy')
    directions = np.stack([(i - W * 0.5) / focal, -(j - H * 0.5) / focal, -np.ones_like(i)], axis=-1)
    rays_d = (camera_pose[:3, :3] @ directions[..., None])[..., 0]  # Rotate to camera frame
    rays_o = np.broadcast_to(camera_pose[:3, -1], rays_d.shape)  # All rays originate from the camera
    return rays_o, rays_d

def uniform_sampling(rays_o, rays_d, near, far, num_samples):
    """
    Sample points along each ray.
    """
    t_vals = np.linspace(near, far, num_samples)
    pts = rays_o[..., None, :] + rays_d[..., None, :] * t_vals[..., None]  # Compute 3D sample points
    return pts, t_vals

def stratified_sampling(near, far, num_samples):
    """
    Perform stratified sampling along the ray.

    Args:
        near (float): The near bound of the sampling range.
        far (float): The far bound of the sampling range.
        num_samples (int): Number of samples along the ray.

    Returns:
        np.ndarray: Sampled depth values along the ray.
    """
    # Step 1: Generate `num_samples` points uniformly between near and far
    t_vals = np.linspace(near, far, num_samples + 1)  # Create bin edges

    # Step 2: Compute midpoints of bins
    midpoints = (t_vals[:-1] + t_vals[1:]) / 2  # ← [Students: Fill in the missing line]

    # Step 3: Add random jitter within each bin
    jitter = (np.random.rand(num_samples) - 0.5) * (t_vals[1] - t_vals[0])  # ← [Students: Fill in the missing line]

    # Step 4: Get final stratified samples
    t_samples = midpoints + jitter  # ← [Students: Fill in the missing line]

    return t_samples

def visualize_sampling(near, far, num_samples):
    """
    Visualizes Uniform vs. Stratified Sampling along a ray.
    This version uses generate_rays() to demonstrate the full ray generation and sampling pipeline.
    """

    # Generate a single dummy ray using camera parameters
    H, W, focal = 1, 1, 1  # Use a 1x1 image with focal length 1 for simplicity
    camera_pose = np.eye(4)  # Identity matrix (no translation or rotation)
    rays_o, rays_d = generate_rays(H, W, focal, camera_pose)  # This returns shape (1, 1, 3)

    # Extract the single ray (shape (3,))
    ray_o = rays_o[0, 0]
    ray_d = rays_d[0, 0]

    # Apply sampling strategies
    _, uniform_samples = uniform_sampling(ray_o, ray_d, near, far, num_samples)      # solve TYPE ERROR
    stratified_samples = stratified_sampling(near, far, num_samples)

    plt.figure(figsize=(10, 4))

    # Plot uniform sampling
    plt.scatter(uniform_samples, np.zeros_like(uniform_samples),
                color='blue', label='Uniform Sampling', marker='|', s=200)

    # Plot stratified sampling
    plt.scatter(stratified_samples, np.ones_like(stratified_samples),
                color='green', label='Stratified Sampling', marker='|', s=200)

    plt.yticks([])  # Remove y-axis labels for clarity
    plt.xlabel("Sampling Depth Along Ray")
    plt.title("Comparison of Uniform vs. Stratified Sampling")
    plt.legend()
    plt.grid(True)
    plt.show()

# Example usage
visualize_sampling(near=0, far=10, num_samples=20)